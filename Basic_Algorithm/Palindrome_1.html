<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
/*SOLUTION 1
DECREMENT FOR LOOP
var str = "civic",
i = str.length,
compare = [];
for(i; i >= 0; i--){
	compare.push(str[i]);
}
compare = compare.join("")
if(compare == str){
	console.log(true);
	console.log(str + " " + compare);
}
else {
	console.log(false)
}
*/

/*SOLUTION 2
TERNARY OPERATOR
var str = "civic";
console.log(str.split('').reverse().join('') === str ? true : false);
*/

/*SOLUTION 3
WHILE LOOP WITHOUT ANY METHODS
var str = "civic",
i = str.length - 1,
compare = "";
while(i >= 0){
	compare += str[i];
	i--
}
console.log(compare == str ? true : false);
*/

/*SOLUTION 4
SIMPLE FUNCTION
function palindrome(str){
	return (str.split('').reverse().join('') === str ? true : false);
}
*/

/*SOLUTION 5
DIVIDE AND CONQUER
var str = "Civic",
part1 = '',
part2 = '';
i = str.length -1;
if(str.length % 2 == 0){
			part1 += str.slice(0,2).push();
			part2 += str.slice()
	for(i; 0 >= i; i--){
		part1 += str.slice(0,2).push();
	}
}*/

//console.log(str.slice(str.length / 2, str.length / 2 + 1));

/*SOLUTION 6
RECURSION*/
function recursive (str) {
	return (str.length % 2 == 1 ? )
}

/*SOLUTION 7
HALF INDEXING function palindrome(str) {
 var len = str.length;
 for (var i = 0; i < len/2; i++) {
   if (str[i] !== str[len - 1 - i]) {
       return false;
   }
 }
 return true;
}
str("civic");

or

function fastestIsPalindrome(str) {
  var len = Math.floor(str.length / 2);
  for (var i = 0; i < len; i++)
    if (str[i] !== str[str.length - i - 1])
      return false;
  return true;
}
/*

/*
SOLUTION 8
RECURSIVE
var low;
var high;
var A = "abcdcba";  

function palindrome(A , low, high){
  A = A.split('');

 if((low > high) || (low == high)){
   return true;
 }

 if(A[low] === A[high]){
   A = A.join('');
   low = low + 1; 
   high = high - 1; 
   return palindrome(A , low, high);
 }
 else{
   return "not a palindrome";
 }
}

palindrome(A, 0, A.length-1);
*/

/*
SOLUTION 9
var teststring = 'abcdedcba';
function IsPalindromeIteration(str){
	var len = str.length, i=0, result = true;
	if (len <= 1) return true;
	while(i != len - i - 1){
		var start = str.charAt(i),
	    end = str.charAt(len - i - 1);
		if (start != end){
			return false;
		}
		i++;
	}
	return result;
}

// res will have a value 'true'
var res = IsPalindromeIteration(teststring);
console.log('Is the string a palindrome ' + res);
Checking palindrome using recursion

/*SOLUTION 10
var teststring = 'abcdedcba';
function IsPalindromeRecursion(str){
    var len = str.length, i=0, result = true;
	if (len <= 1) return true;
	if (str.charAt(i) != str.charAt(len - i - 1)){
		return false;
	  }else{
	  	i++;
	  	IsPalindromeRecursion(str.substr(1,str.length -2));
	  }
	  return result;
}
// this will be true
var res = IsPalindromeRecursion(teststring);
console.log('Is the string a palindrome ' + res);
function isPalindrome(string) {
  if(string.length <= 1) return true; // 1
  if(string.charAt(0) != string.charAt(string.length - 1)) return false; // 2
  return isPalindrome( string.substr(1, string.length - 2) ); // 3
}
 
isPalindrome('anna'); // true
isPalindrome('ana'); // true
isPalindrome('a'); // true
isPalindrome('lucy'); // false
isPalindrome('anya'); // false
*/

/*GOD SOLUTION
	
The most important thing to do when solving a Technical Test is Don't use shortcut methods -- they want to see how you think algorithmically! Not your use of methods.

Here is one that I came up with (45 minutes after I blew the test). There are a couple optimizations to make though. When writing any algorithm, its best to assume false and alter the logic if its looking to be true.

isPalindrome():

Basically, to make this run in O(N) (linear) complexity you want to have 2 iterators whose vectors point towards each other. Meaning, one iterator that starts at the beginning and one that starts at the end, each traveling inward. You could have the iterators traverse the whole array and use a condition to break/return once they meet in the middle, but it may save some work to only give each iterator a half-length by default.

for loops seem to force the use of more checks, so I used while loops - which I'm less comfortable with.

Here's the code:
*/
/**
 * TODO: If func counts out, let it return 0
 *  * Assume !isPalindrome (invert logic)
 */
 /*
function isPalindrome(S){
    var s = S
      , len = s.length
      , mid = len/2;
      , i = 0, j = len-1;

    while(i<mid){
        var l = s.charAt(i);
        while(j>=mid){
            var r = s.charAt(j);
            if(l === r){
                console.log('@while *', i, l, '...', j, r);
                --j;
                break;
            }
            console.log('@while !', i, l, '...', j, r);
            return 0;
        }
        ++i;
    }
    return 1;
}

var nooe = solution('neveroddoreven');  // even char length
var kayak = solution('kayak');  // odd char length
var kayaks = solution('kayaks');

console.log('@isPalindrome', nooe, kayak, kayaks);
*/
</script>
</body>
</html>
